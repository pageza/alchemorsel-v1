# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: CI Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    env:
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ vars.POSTGRES_DB }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      POSTGRES_HOST: ${{vars.POSTGRES_HOST}}
      POSTGRES_PORT: ${{vars.POSTGRES_PORT}}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create dummy .env file
        run: touch .env

      - name: Create dummy .env.production file
        run: |
          echo -n "JWT_SECRET=" > .env
          printf "%s" "${JWT_SECRET%$'\n'}" >> .env

      - name: Verify .env file exists
        run: |
          echo "Listing contents of .env:"
          ls -la .env
          echo "Dumping contents of .env:"
          cat .env
          SECRET=$(cut -d'=' -f2- .env)
          HASH=$(echo -n "$SECRET" | sha256sum | awk '{print $1}')
          echo "JWT_SECRET hash: $HASH"
          echo "Checking environment variable JWT_SECRET:"
          if [ -n "$JWT_SECRET" ]; then
              echo "JWT_SECRET environment is set."
              CLEANED_ENV=$(echo -n "$JWT_SECRET" | tr -d "\n")
              echo "Cleaned JWT_SECRET:" "$CLEANED_ENV"
              echo "Cleaned JWT_SECRET in hex:"; echo -n "$CLEANED_ENV" | hexdump -C
              ENV_HASH=$(printf "%s" "$CLEANED_ENV" | sha256sum | awk '{print $1}')
              echo "JWT_SECRET environment hash: $ENV_HASH"
              if [ "$HASH" != "$ENV_HASH" ]; then
                  echo "WARNING: JWT_SECRET hash from .env ($HASH) does not match JWT_SECRET from environment ($ENV_HASH)."
              else
                  echo "JWT_SECRET hash from .env matches environment variable."
              fi
          else
              echo "JWT_SECRET environment variable is not set."
          fi
          FILE_LEN=$(echo -n "$SECRET" | wc -c)
          ENV_LEN=$(echo -n "$CLEANED_ENV" | wc -c)
          echo "JWT_SECRET value lengths:"
          echo "Length from .env: $FILE_LEN"
          echo "Length from environment variable: $ENV_LEN"
          echo "JWT_SECRET snippet from file: ${SECRET:0:5}"
          echo "JWT_SECRET snippet from environment: ${JWT_SECRET:0:5}"
          echo "JWT_SECRET from file in hex:"
          echo -n "$SECRET" | hexdump -C
          echo "JWT_SECRET from environment in hex:"
          echo -n "$JWT_SECRET" | hexdump -C

      - name: Debug JWT_SECRET further
        run: |
          echo "JWT_SECRET raw hexdump (first 64 bytes):"
          echo -n "$JWT_SECRET" | hexdump -C | head -n 4
          echo "JWT_SECRET environment variable length: ${#JWT_SECRET}"

      - name: Print full JWT_SECRET environment variable (debug)
        run: env | grep -i jwt_secret

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Install dependencies
        run: |
          go mod download

      - name: Run Unit Tests
        run: go test -v ./...

      - name: Start Docker Services
        run: docker compose --env-file .env up --build -d

      - name: Debug Environment Variables
        run: echo "POSTGRES_USER=$POSTGRES_USER, POSTGRES_DB=$POSTGRES_DB, JWT_SECRET=$JWT_SECRET, POSTGRES_HOST=$POSTGRES_HOST, POSTGRES_PORT=$POSTGRES_PORT"

      - name: Debug Docker Compose Config
        run: docker compose config

      - name: Run Integration Tests
        run: go test -v ./tests/integration/...

      - name: Display Docker Containers
        run: docker ps

      - name: Display All Containers
        run: docker ps -a

      - name: List collections folder
        run: ls -la ${{ github.workspace }}/tests/collections

      - name: Generate Newman Environment File
        run: |
          echo '{\n            "id": "env-local",\n            "name": "Local Environment",\n            "values": [\n              {\n                "key": "baseUrl",\n                "value": "http://localhost:8080",\n                "enabled": true,\n                "type": "text"\n              }\n            ]\n          }' > tests/environment.json

      - name: Run Newman E2E Tests for Recipe Endpoints
        run: |
          docker run --rm --network container:app \
            -v ${{ github.workspace }}/tests/collections:/etc/newman/collections \
            -v ${{ github.workspace }}/tests/environment.json:/etc/newman/environment.json \
            postman/newman:alpine run /etc/newman/collections/recipe_endpoints.postman_collection.json \
              --environment "/etc/newman/environment.json" --delay-request 500 --reporters cli,junit

      - name: Run Newman E2E Tests for User Endpoints
        run: |
          docker run --rm --network container:app \
            -v ${{ github.workspace }}/tests/collections:/etc/newman/collections \
            -v ${{ github.workspace }}/tests/environment.json:/etc/newman/environment.json \
            postman/newman:alpine run /etc/newman/collections/user_endpoints.postman_collection.json \
              --environment "/etc/newman/environment.json" --delay-request 500 --reporters cli,junit

      - name: Dump Docker Container Logs
        if: always()
        run: docker compose -f docker-compose.yml logs

      - name: Print logs on failure
        if: failure()
        run: docker compose -f docker-compose.yml logs

      - name: Ensure .env.production exists for cleanup
        run: |
          if [ ! -f .env.production ]; then
            echo 'DUMMY=true' > .env.production
          fi
          ls -la .env.production

      - name: Cleanup
        run: docker compose --env-file .env -f docker-compose.yml down -v 